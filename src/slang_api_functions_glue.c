#define HAVE_LONG_LONG 1
/* * This file was generated by SLIRP, the (Sl)ang (I)nte(r)face (P)ackage,
 * a S-Lang module code generator for C, C++, and FORTRAN.
 *
 * Copyright (C) 2003-2009 Massachusetts Institute of Technology 
 * Copyright (C) 2002 Michael S. Noble <mnoble@space.mit.edu>
 *
 * SLIRP is free software, and may be used under the conditions stipulated
 * in the COPYRIGHT agreement bundled within the SLIRP distribution.
 */
#include <stdlib.h>		/* SLIRP common {{{ */
#include <unistd.h>
#include <string.h>
#include <stdarg.h>
#include <ctype.h>
#include <slang.h>

#define SAFE_DEREF_OPAQUE(po)		(po == NULL ? NULL : po->instance)
#define SAFE_DEREF_ARRAY(pa)		(pa == NULL ? NULL : pa->data)
#define SLang_pop_array(x)		SLang_pop_array(x, 1)
#define SLang_pop_string(x)             ( (SLang_peek_at_stack() == SLANG_NULL_TYPE && (SLdo_pop() || 1)) ? ((*x = NULL) || 1): SLang_pop_slstring(x))
#define SLang_push_size_t		SLang_push_ulong
#define SLang_push_ptrdiff_t		SLang_push_long

#define pop_defaultable(argno, kind, type, obj, value) \
   (SLang_Num_Function_Args >= argno ? SLang_pop_##kind ( (type*)&obj) : ((obj = value) || ( (void*)&obj > (void*)0) ) )

#ifdef __cplusplus
#define LINKAGE "C"
#else
#define LINKAGE
#endif

#define USAGE(msg) \
    {SLang_verror(SL_USAGE_ERROR, (char*)"Usage: %s", msg); return;}

static void Slirp_usage(int i, int j, int flags);

static int slang_abi_mismatch(void)
{
   long module_abi = SLANG_VERSION / 10000;
   long app_abi    = SLang_Version / 10000;

   if (module_abi != app_abi) {
	SLang_verror(SL_APPLICATION_ERROR, (char*)
		"S-Lang library abi mismatch\nmodule: %s, application: %s",
		SLANG_VERSION_STRING, SLang_Version_String);
	return 1;
   }
			        
   return 0;
} /* }}} */

static char *slns;  /* slang namespace active at time of module load */
#include "slang_api_functions.h"
#define BEGIN_DECLS
#define END_DECLS
#define SLIRP_EXTERN
BEGIN_DECLS				/* Opaque handling code {{{ */

#define SLIRP_ABI_VERSION			10500

typedef void            (*FINALIZER)            (void*);
typedef void            (*INITIALIZER)          (void*);

typedef struct _Slirp_Type {
   SLang_Class_Type	*slclass;	/* SLang type class for this type */
   struct _Slirp_Type	*parent;	/* NULL if type has no ancestors  */
   FINALIZER		finalizer;
   INITIALIZER		initializer;
} Slirp_Type;

typedef struct _Slirp_Opaque {
   Slirp_Type *type;
   SLang_MMT_Type *mmt;
   void* instance;
   int deletion_in_progress;
   int free_me_too;		       /* if non-zero, free MMT, then struct */
   int owns_ref;		       /* if non-zero, do not free instance */
} Slirp_Opaque;

static void SLang_free_opaque (Slirp_Opaque *o)
{
   SLang_MMT_Type *mmt;

   if ((o == NULL)
       || (o->deletion_in_progress))
     return;

   mmt = o->mmt;
   if (mmt == NULL)
     return;

   o->mmt = NULL;
   o->deletion_in_progress = 1;
   SLang_free_mmt (mmt);
   o->deletion_in_progress = 0;
   if (o->free_me_too)
     SLfree ((char *) o);
}


static int opaque_typecast (SLtype from_type, VOID_STAR from_p,
			unsigned int num, SLtype to_type, VOID_STAR to_p)
{
   unsigned int i;
   SLang_MMT_Type **from = (SLang_MMT_Type**)from_p;
   SLang_MMT_Type **to   = (SLang_MMT_Type**)to_p;

   (void) from_type; (void) to_type; 

   for (i=0; i < num; i++) {
	to[i] = from[i];	/* FIXME: typeof() still reports prev type */
	if (from[i] != NULL)
	   SLang_inc_mmt(from[i]);
   }

   return 1;
}

static int opaque_search(const void* key, const void *elem)
{
   return *(SLtype*)key - SLclass_get_class_id((*(Slirp_Type**)elem)->slclass);
}

static void destroy_opaque(SLtype type, VOID_STAR w)
{
   Slirp_Opaque *ot = (Slirp_Opaque*)w;

   (void) type;

   if ((ot->type != NULL)
       && (ot->type->finalizer != NULL)
       && (ot->instance != NULL))
     {
	if (ot->owns_ref == 0)
	  (*ot->type->finalizer) (ot->instance);
	ot->instance = NULL;
     }

   if (ot->deletion_in_progress)
     {
	/* Evidently, the MMT container is being destroyed from SLang_free_mmt.
	 * Let it perform the final free.
	 */
	ot->free_me_too = 1;
	return;
     }
   SLfree( (char*)ot );
}
END_DECLS

SLIRP_EXTERN SLtype void_ptr_Type;	/* These opaque pointer types must */
SLIRP_EXTERN SLtype string_ptr_Type;	/* be kept in sync with opaques.c  */
SLIRP_EXTERN SLtype uchar_ptr_Type;
SLIRP_EXTERN SLtype short_ptr_Type;
SLIRP_EXTERN SLtype ushort_ptr_Type;
SLIRP_EXTERN SLtype int_ptr_Type;
SLIRP_EXTERN SLtype uint_ptr_Type;
SLIRP_EXTERN SLtype long_ptr_Type;
SLIRP_EXTERN SLtype ulong_ptr_Type;
SLIRP_EXTERN SLtype float_ptr_Type;
SLIRP_EXTERN SLtype double_ptr_Type;
SLIRP_EXTERN SLtype opaque_ptr_Type;
SLIRP_EXTERN SLtype file_ptr_Type;

typedef struct _Reserved_Opaque_Type {
   char	  *name;
   SLtype *type;		/* SLtype of opaque pointer defined by this */
   SLtype masked_type;		/* SLtype of datum to which this points */
} Reserved_Opaque_Type;

SLIRP_EXTERN Slirp_Type	**Slirp_Opaque_Types;
SLIRP_EXTERN SLtype 	Slirp_Num_Opaque_Types;
SLIRP_EXTERN SLtype	First_Opaque_Type;
SLIRP_EXTERN SLtype	Last_Reserved_Opaque_Type;

static Reserved_Opaque_Type Reserved_Opaque_Types[] = {

   { (char*)"void_ptr",		&void_ptr_Type,		SLANG_ANY_TYPE,    },
   { (char*)"int_ptr",		&int_ptr_Type,		SLANG_INT_TYPE,    },
   { (char*)"double_ptr",	&double_ptr_Type,	SLANG_DOUBLE_TYPE, },
   { (char*)"opaque_ptr",	&opaque_ptr_Type,	SLANG_ANY_TYPE,	   },
   { (char*)"file_ptr",		&file_ptr_Type,		SLANG_FILE_PTR_TYPE,},
   { (char*)"float_ptr",	&float_ptr_Type,	SLANG_FLOAT_TYPE,  },
   { (char*)"long_ptr",		&long_ptr_Type,		SLANG_LONG_TYPE,   },
   { (char*)"string_ptr",	&string_ptr_Type,	SLANG_STRING_TYPE, },
   { (char*)"uint_ptr",		&uint_ptr_Type,		SLANG_UINT_TYPE,   },
   { (char*)"short_ptr",	&short_ptr_Type,	SLANG_SHORT_TYPE,  },
   { (char*)"ulong_ptr",	&ulong_ptr_Type,	SLANG_ULONG_TYPE,  },
   { (char*)"ushort_ptr",	&ushort_ptr_Type,	SLANG_USHORT_TYPE, },
   { (char*)"uchar_ptr",	&uchar_ptr_Type,	SLANG_UCHAR_TYPE,  },
   { NULL, NULL, 0, }
};

#define NUM_RESERVED_OPAQUES \
	sizeof(Reserved_Opaque_Types) / sizeof(Reserved_Opaque_Type) - 1

static Slirp_Type* sltype_to_slirp_type(SLtype sltype)
{
   Slirp_Type **ot = (Slirp_Type**) bsearch( (const void*) &sltype,
	 		(const void*) Slirp_Opaque_Types,
			(size_t) Slirp_Num_Opaque_Types,
			sizeof(Slirp_Type*), opaque_search);

   if (ot != NULL) return *ot;
   return NULL;
}

static SLang_MMT_Type*
create_opaque_mmt(SLtype type, void *instance, unsigned int owns_ref)
{
   SLang_MMT_Type *mmt = NULL;
   Slirp_Opaque *ot = (Slirp_Opaque*) SLcalloc(1, sizeof(Slirp_Opaque));

   if (ot != NULL) {

	ot->instance = instance;
	ot->owns_ref = owns_ref;
	ot->mmt      = NULL;

	if ( (ot->type = sltype_to_slirp_type(type)) != NULL) {

	   if (ot->type->initializer != NULL)
		(*ot->type->initializer) (ot->instance);

	   mmt = SLang_create_mmt (type, (VOID_STAR) ot);
	}

	if (mmt == NULL)
	   SLfree((char*)ot);
   }

   return mmt;
}

static int SLang_push_opaque(SLtype type, void *instance, unsigned int owns_ref)
{
   SLang_MMT_Type *mmt;

   if (instance == NULL)
      return SLang_push_null();

   mmt = create_opaque_mmt(type, instance, owns_ref);
   if (NULL == mmt)
      return -1;

   if (-1 == SLang_push_mmt (mmt))
     {
	SLang_free_mmt (mmt);
	return -1;
     }
   return 0;
}

static int SLang_pop_opaque (SLtype type, void **instance, Slirp_Opaque **o)
{
   Slirp_Opaque *ot;
   SLang_MMT_Type *mmt = NULL;

   if (instance != NULL) *instance = NULL;
   *o = NULL;

   if ((type == file_ptr_Type)
       && (SLang_peek_at_stack() == SLANG_FILE_PTR_TYPE))
     {
	FILE *fp;
	if (-1 == SLang_pop_fileptr(&mmt, &fp))
	  return -1;

	ot = (Slirp_Opaque*) SLcalloc(1, sizeof(Slirp_Opaque));
	if (ot == NULL)
	  {
	     SLang_free_mmt(mmt);
	     return -1;
	  }
	ot->mmt = mmt;
	ot->free_me_too = 1;
	*instance = (void*)fp;
	*o = ot;
	return 0;
   }

   if (NULL == (mmt = SLang_pop_mmt (type)))
     return -1;

   if (NULL == (ot = (Slirp_Opaque*) SLang_object_from_mmt (mmt))
       || (ot->instance == NULL))
     {
	SLang_verror (SL_INVALID_PARM, "%s", "slirp: pop_opaque: instance=NULL");
	SLang_free_mmt (mmt);
	return -1;
     }

   /* This creates a circular reference:
    *    mmt->ot->mmt
    */
   ot->mmt = mmt;
   if (instance != NULL)
     *instance = ot->instance;
   *o = ot;
   return 0;
}

static unsigned int
allocate_opaque(char *name, FINALIZER fzer, INITIALIZER izer, SLtype parent_id,
		int (*sget)(SLtype, SLFUTURE_CONST char *), int (*sput)(SLtype, SLFUTURE_CONST char *))
{
   /* Returning from here with anything but a positive id is fatal */
   SLtype new_type, ancestor_type;
   Slirp_Type *type , *parent = NULL;
   SLang_Class_Type *new_class = SLclass_allocate_class (name);

   if (new_class == NULL) return SLANG_UNDEFINED_TYPE;

   (void) SLclass_set_destroy_function (new_class, destroy_opaque);
   if (-1 == SLclass_register_class (new_class, SLANG_VOID_TYPE,
				     sizeof(Slirp_Opaque),
				     SLANG_CLASS_TYPE_MMT))
	return SLANG_UNDEFINED_TYPE;

   new_type = SLclass_get_class_id(new_class);
   if (parent_id) {

	type = parent = sltype_to_slirp_type(parent_id);

	while (type) {

	   ancestor_type = SLclass_get_class_id(type->slclass);

	   /* Support downcasting ancestor types to this type */
	   if (-1 == SLclass_add_typecast (ancestor_type, new_type,
		    					opaque_typecast, 1))
		return SLANG_UNDEFINED_TYPE;

	   /* Support upcasting this type to each ancestor type */
	   if (-1 == SLclass_add_typecast (new_type, ancestor_type,
							opaque_typecast, 1))
		return SLANG_UNDEFINED_TYPE;

	   type = type->parent;
	}
   }

   if ( (sget != NULL && SLclass_set_sget_function(new_class, sget) == -1) ||
	(sput != NULL && SLclass_set_sput_function(new_class, sput) == -1))
	return SLANG_UNDEFINED_TYPE;
	
   if ( (type = (Slirp_Type*) SLmalloc(sizeof(Slirp_Type))) == NULL)
	return SLANG_UNDEFINED_TYPE;

   type->slclass = new_class;
   type->parent = parent;
   type->finalizer = fzer;
   type->initializer = izer;
   Slirp_Opaque_Types[ Slirp_Num_Opaque_Types++ ] = type;

   return new_type;
}

static int allocate_reserved_opaque_types(void)
{
   Reserved_Opaque_Type *pt;
   long abi_version = -1;

   if ( SLang_is_defined((char*)"_slirp_initialized")) {

	if ( SLang_is_defined((char*)"_slirp_abi_version") == 0  ||
		SLang_load_string((char*)"_slirp_abi_version;") == -1 ||
		SLang_pop_long(&abi_version) == -1 ||
		abi_version != SLIRP_ABI_VERSION)
	{
	   SLang_verror(SL_APPLICATION_ERROR,
		(char*) "SLIRP abi mismatch: want version %ld, have %ld\n",
		(long)SLIRP_ABI_VERSION, abi_version);
	   return -1;
	}

	return 0;
   }

   (void)SLang_load_string((char*)"public variable _slirp_initialized=1;");
   (void)SLang_push_int(SLIRP_ABI_VERSION);
   (void)SLang_load_string((char*)"public variable _slirp_abi_version=();");

   Slirp_Num_Opaque_Types = 0;

   if ( NULL == (Slirp_Opaque_Types = (Slirp_Type**) SLmalloc
			( sizeof(Slirp_Type*) * (NUM_RESERVED_OPAQUES + 1))))
      return -1;

   Slirp_Opaque_Types[0] = NULL;

   pt = Reserved_Opaque_Types;
   while (pt->name != NULL) {
	if ((*pt->type = allocate_opaque(pt->name, NULL,NULL,0,NULL,NULL)) ==
	      						SLANG_UNDEFINED_TYPE)
		return -1;
	   pt++;
	}

   /* Loop again, to enable casts to/from generic pointer type */
   pt = Reserved_Opaque_Types + 1;
   while (pt->name != NULL) {

	if (-1 == SLclass_add_typecast (*pt->type, void_ptr_Type,
							opaque_typecast, 1))
	   return SLANG_UNDEFINED_TYPE;

	if (-1 == SLclass_add_typecast (void_ptr_Type, *pt->type,
							opaque_typecast, 1))
	   return SLANG_UNDEFINED_TYPE;

	pt++;
   }

   First_Opaque_Type = *Reserved_Opaque_Types[0].type;
   Last_Reserved_Opaque_Type = First_Opaque_Type + NUM_RESERVED_OPAQUES - 1;

   return 0;
} /* }}} */
static unsigned char map_scalars_to_refs = 0;

typedef struct _Slirp_Ref {			/* Ref handling code {{{ */
#define	REF_FLAG_FREE_DATA			0x01
#define	REF_FLAG_IS_OPAQUE			0x02
#define	REF_FLAG_COLUMN_MAJOR			0x04
#define	REF_FLAG_ARRAY_EXPECTED			0x08
   unsigned int		flags;		/* Slirp_Ref encapsulates S-Lang    */
   SLtype		sltype;		/* array, ref, and MMT types, the   */
   size_t		sizeof_type;	/* latter two of which are seen as  */
   void			**data;		/* pointing to a single object      */
   unsigned int		vstride;	/* how to find "next" vectored elem */
   SLang_Array_Type	*array;
   SLang_Ref_Type	*ref;
   SLang_MMT_Type	*mmt;		/* mmt supports passing around C    */
} Slirp_Ref;				/* ptr arrays of indeterminate size */

static Slirp_Ref* ref_new(SLtype t,size_t typesize, void *d,unsigned int flags)
{
   Slirp_Ref *ref;
   if ((ref = (Slirp_Ref*)SLcalloc( sizeof(Slirp_Ref), 1)) != NULL) {
	ref->sltype = t;
	ref->sizeof_type = typesize;
	ref->flags = flags;
	ref->data = (void**)d;
	*ref->data = NULL;
   }
   return ref;
}

static int ref_finalize(Slirp_Ref *r) /* {{{ */
{
   int status = 0;
   if (r == NULL) return 0;

   if (r->ref) {

        void *ref_value = NULL; SLtype ref_type = 0; double dc[2];

	if (r->flags & REF_FLAG_IS_OPAQUE) { 	/* wrap aggregates/opaques  */
#ifdef NUM_RESERVED_OPAQUES			/* in mmt before ref assign */
	   void *opaqval = *r->data;		/* the mmt w/be freed when  */
	   if (opaqval == NULL) {		/* the S-Lang object goes   */
		ref_value = NULL;		/* out of scope		    */
		ref_type = SLANG_NULL_TYPE;
	   }
	   else {
		SLang_MMT_Type *mmt = create_opaque_mmt(r->sltype, opaqval, 0);
		ref_value = &mmt;
		ref_type = r->sltype;
	   }
#endif
	}
	else {
	   ref_type = r->sltype;
	   if (ref_type == SLANG_COMPLEX_TYPE && r->sizeof_type < sizeof(dc)) {
		float *fc = (float*) r->data;
		dc[0] = fc[0];
		dc[1] = fc[1];
		ref_value = dc;
	   }
	   else
		ref_value = r->data;
	}

	status = SLang_assign_to_ref (r->ref, ref_type, ref_value);
	SLang_free_ref(r->ref);
   }
   else if (r->array) {
#ifdef HAVE_FORTRAN_CODE
	if ((r->flags & REF_FLAG_COLUMN_MAJOR) && TRANSPOSE(1,r->array) == -1)
		return -1;
#endif
	SLang_free_array(r->array);
   }
   else if (r->mmt)
	SLang_free_mmt(r->mmt);

   if (r->flags & REF_FLAG_FREE_DATA)
	SLfree( (char*) r->data );

   SLfree((char*)r);
   return status;
} /* }}} */

static void finalize_refs(unsigned int nargs, ...) /* {{{ */
{
   va_list ap;
   va_start(ap, nargs);
   while (nargs--) ref_finalize(va_arg(ap, Slirp_Ref *));
   va_end(ap);
} /* }}} */

static unsigned int ref_get_size(Slirp_Ref *r, int which_dimension) /* {{{ */
{
   if (r->array) {
	if (which_dimension == 0)
	   return (unsigned int)r->array->num_elements;
	else if (which_dimension < 0)
	   return r->array->num_dims;
	else {
	   which_dimension--;
	   if ((unsigned int)which_dimension < r->array->num_dims)
		return (unsigned int)r->array->dims[which_dimension];
	   else
		return 0;
	}
   }

   return 1;
} /* }}} */

extern LINKAGE int _SLang_get_class_type (SLtype t);	/* quasi-public  */

#ifdef NUM_RESERVED_OPAQUES
static SLtype sltype_to_opaque_ptr_type(SLtype sltype) /*{{{*/
{
   Reserved_Opaque_Type *pt;

   if (sltype > Last_Reserved_Opaque_Type) return opaque_ptr_Type;
   if (sltype == void_ptr_Type) return void_ptr_Type;

   pt = Reserved_Opaque_Types;		/* sequential search, but s/b < O(n) */
   while (pt->name) {			/* since list is ordered by expected */
	if (pt->masked_type == sltype)	/* frequency of use for each SLtype  */
	   return *pt->type;		
	pt++;
   }
   return 0;
} /*}}}*/
#endif

static int try_pop_mmt(SLtype type, SLang_MMT_Type **mmt) /*{{{*/
{
   static SLang_Name_Type *cl_type_func;	/* SLang_pop_mmt doesn't */
   int classtype;				/* validate that type is */
						/* an MMT, so we do here */
   *mmt = NULL;					/* FIXME: remove v2.0.7  */

   if (cl_type_func == NULL)
	cl_type_func = SLang_get_function( (char*) "__class_type");

   if (cl_type_func == NULL)
      return 0;

   if (-1 == SLang_push_datatype(type) ||		/* do the hard way, */
	-1 == SLexecute_function(cl_type_func) ||	/* as C api lacks   */
	-1 == SLang_pop_int(&classtype))		/* get_class_type() */
	return -1;

   if (classtype == SLANG_CLASS_TYPE_MMT) {
	*mmt = SLang_pop_mmt(type);
	return 1;
   }
   return 0;
} /*}}}*/

#define POP_FLAG_NULLABLE	0x1
#define POP_FLAG_VECTORIZE	0x2
static int pop_array_or_ref(Slirp_Ref *r, int flags, int defaultable) /*{{{*/
{
   SLtype type;
   unsigned int i, objtype;
#ifdef NUM_RESERVED_OPAQUES
   unsigned int is_opaque;
#endif

   if (r == NULL) {
	SLang_verror(SL_INTRINSIC_ERROR, (char*)"Attempted NULL reference (out of memory?)");
	return -1;
   }

   if (defaultable && SLang_Num_Function_Args < defaultable) {
	r->ref   = NULL;	/* observe that only NULL can be */
	*r->data = NULL;	/* assigned as the default value */
	return 0;
   }
   
   objtype = SLang_peek_at_stack();

   if ((flags & POP_FLAG_NULLABLE) && objtype == SLANG_NULL_TYPE) {
	r->ref   = NULL;		/* nullable flag: a pointer arg for */
	*r->data = NULL;		/* which NULL is a legitimate value */
	return SLang_pop_null ();
   }

   type = r->sltype;

#ifdef NUM_RESERVED_OPAQUES
   is_opaque =(type >= First_Opaque_Type && sltype_to_slirp_type(type) != NULL);
   if (is_opaque) r->flags |= REF_FLAG_IS_OPAQUE;
#endif

   switch(objtype) {

	case SLANG_ARRAY_TYPE:

	   if (SLang_pop_array_of_type(&r->array, type) == -1)
		return -1;

#ifdef HAVE_FORTRAN_CODE
	   if (r->flags & REF_FLAG_COLUMN_MAJOR) {
		if (flags & POP_FLAG_VECTORIZE)		/* vectorizable arrs*/
		   r->flags ^= REF_FLAG_COLUMN_MAJOR;   /* r not transposed */
		else if (TRANSPOSE(0,r->array) == -1)
		   return -1;
	   }
#endif

	   i = r->array->num_elements;
#ifdef NUM_RESERVED_OPAQUES
	   if (is_opaque) {
	      	Slirp_Opaque *ot;
		SLang_MMT_Type** mmts = (SLang_MMT_Type**)r->array->data;
		void **arr = (void**)SLmalloc(i * sizeof(void*) );
		if (arr == NULL) return -1;

		while (i--) {
		   ot = (Slirp_Opaque*) SLang_object_from_mmt (mmts[i]);
		   if (ot == NULL) {
			SLfree((char*)arr);
			return -1;
		   }
		   arr[i] = ot->instance;
		}

		*r->data = (void*)arr; r->data = (void**)arr;
		r->flags |= REF_FLAG_FREE_DATA;
	   }
	   else
#endif
	   if (type == SLANG_COMPLEX_TYPE &&
		 		r->sizeof_type < r->array->sizeof_type) {
		double *dc = (double*) r->array->data;
		float  *fc = (float *) SLmalloc(i * r->sizeof_type);
		if (fc == NULL) return -1;
		*r->data = fc; r->data = (void**)fc;
		while (i--) { *fc++ = (float) *dc++; *fc++ = (float) *dc++; }
		r->flags |= REF_FLAG_FREE_DATA;
	   }
	   else {
		*r->data = r->array->data;
		r->data = (void**)*r->data;
	   }

	   break;

	case SLANG_REF_TYPE:

	   /* Refs can only send values one-way (C to S-Lang, not reverse) */
	   if (SLang_pop_ref(&r->ref) == -1)
		return -1;

	   /* Ref is assumed to point to a scalar instance of the  */
	   /* refd type, so declare enough space to hold one such. */
	   *r->data = (void*)SLmalloc(r->sizeof_type);
	   if (*r->data == NULL) return -1;
	   memset(*r->data, 0, r->sizeof_type);
	   r->flags |= REF_FLAG_FREE_DATA;
	   r->data = (void**)*r->data;
	   break;

	/* Allow scalars to used as if they were 1-element arrays */
	case SLANG_CHAR_TYPE: case SLANG_UCHAR_TYPE:
	case SLANG_SHORT_TYPE: case SLANG_USHORT_TYPE:
	case SLANG_INT_TYPE: case SLANG_UINT_TYPE:
	case SLANG_LONG_TYPE: case SLANG_ULONG_TYPE:
	case SLANG_FLOAT_TYPE: case SLANG_DOUBLE_TYPE:
	case SLANG_COMPLEX_TYPE: case SLANG_STRING_TYPE:

	   /* Accomodate FORTRAN-style pass by reference semantics */
	   if (map_scalars_to_refs &&
		 	SLang_pop_array_of_type(&r->array,type) == 0) {

		*r->data = (void*)SLmalloc(r->sizeof_type);
		if (*r->data == NULL) return -1;

		if (r->sizeof_type == r->array->sizeof_type)
		   memcpy(*r->data, r->array->data, r->sizeof_type);
		else if (type == SLANG_COMPLEX_TYPE) {
		   double *dc = (double*) r->array->data;
		   float  *fc = (float*) *r->data;
		   fc[0] = (float)dc[0];
		   fc[1] = (float)dc[1];
		}
		else  {
		   SLang_verror(SL_TYPE_MISMATCH, (char*)
			"mismatched type sizes, when popping scalar as ref");
		   SLang_free_array(r->array);
		   return -1;
		}

		r->data = (void**)*r->data;
		r->flags |= REF_FLAG_FREE_DATA;
		/* Nullify to distinguish between vectored/non-vectored args */
		SLang_free_array(r->array); r->array = NULL;
		break;
	   }				/* intentional fallthrough */

	default:

#ifdef NUM_RESERVED_OPAQUES
	   if (objtype >= First_Opaque_Type && 
		 		sltype_to_slirp_type(objtype) != NULL) {

		if (!(flags & POP_FLAG_VECTORIZE))
		   type = sltype_to_opaque_ptr_type(type);

		if (type) {

		   Slirp_Opaque *otp;
		   if (SLang_pop_opaque(type, NULL, &otp) == -1)
			return -1;
		
		   if (flags & POP_FLAG_VECTORIZE) {
			void **arr = (void**) SLmalloc(sizeof(void*));
			if (arr == NULL) return -1;
			arr[0] = otp->instance;
			*r->data = arr;
			r->flags |= REF_FLAG_FREE_DATA;
		   }
		   else
			*r->data = otp->instance;

		   r->data = (void**)*r->data;
		   r->mmt = otp->mmt;
		   return 0;
		}
	   }
	   else
#endif
	   if ( try_pop_mmt(objtype, &r->mmt) == 1 &&
		(*r->data = SLang_object_from_mmt (r->mmt)) != NULL) {
		   r->data = (void**)*r->data;	 /* not flagged for freeing */
		   return 0;
	   }

	   SLang_verror(SL_TYPE_MISMATCH, (char*)
			"context requires array, ref, or opaque pointer");
	   return -1;
   }
   return 0;
} /*}}}*/
/* }}} */

/* Wrapper functions */ /* {{{ */
static void sl_set_action_hook (void)
{
   int retval;
   char* arg1;
   char* arg2;
   char* arg3;
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 3) goto usage_label;
   if (-1 == SLang_pop_string((char**)&arg3)) goto usage_label;
   if (-1 == SLang_pop_string((char**)&arg2)) goto free_and_return_3;
   if (-1 == SLang_pop_string((char**)&arg1)) goto free_and_return_2;
   issue_usage = 0;

   retval = slang_api__set_action_hook(arg1, arg2, arg3);
   (void)SLang_push_int(retval);
   goto free_and_return;
free_and_return:
   /* drop */
   SLang_free_slstring(arg1);
free_and_return_2:
   SLang_free_slstring(arg2);
free_and_return_3:
   SLang_free_slstring(arg3);
usage_label:
   if (issue_usage) Slirp_usage (0, 0, 0);
}

static void sl_cure_backspace (void)
{
   int retval;
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 0) goto usage_label;
   issue_usage = 0;

   retval = slang_api__cure_backspace();
   (void)SLang_push_int(retval);
   goto free_and_return;
free_and_return:
   /* drop */
usage_label:
   if (issue_usage) Slirp_usage (1, 1, 0);
}

static void sl_add_new_action (void)
{
   int retval;
   char* arg1;
   int arg2;
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 2) goto usage_label;
   if (-1 == SLang_pop_int((int*)&arg2)) goto usage_label;
   if (-1 == SLang_pop_string((char**)&arg1)) goto usage_label;
   issue_usage = 0;

   retval = keybind_add_new_action(arg1,  arg2);
   (void)SLang_push_int(retval);
   goto free_and_return;
free_and_return:
   /* drop */
   SLang_free_slstring(arg1);
usage_label:
   if (issue_usage) Slirp_usage (2, 2, 0);
}

static void sl_editor_map_key_to_func (void)
{
   int retval;
   char* arg1;
   char* arg2;
   char* arg3;
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 3) goto usage_label;
   if (-1 == SLang_pop_string((char**)&arg3)) goto usage_label;
   if (-1 == SLang_pop_string((char**)&arg2)) goto free_and_return_3;
   if (-1 == SLang_pop_string((char**)&arg1)) goto free_and_return_2;
   issue_usage = 0;

   retval = slang_api__editor_map_key_to_func(arg1, arg2, arg3);
   (void)SLang_push_int(retval);
   goto free_and_return;
free_and_return:
   /* drop */
   SLang_free_slstring(arg1);
free_and_return_2:
   SLang_free_slstring(arg2);
free_and_return_3:
   SLang_free_slstring(arg3);
usage_label:
   if (issue_usage) Slirp_usage (3, 3, 0);
}

static void sl_editor_map_key_to_action (void)
{
   int retval;
   char* arg1;
   char* arg2;
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 2) goto usage_label;
   if (-1 == SLang_pop_string((char**)&arg2)) goto usage_label;
   if (-1 == SLang_pop_string((char**)&arg1)) goto free_and_return_2;
   issue_usage = 0;

   retval = slang_api__editor_map_key_to_action(arg1, arg2);
   (void)SLang_push_int(retval);
   goto free_and_return;
free_and_return:
   /* drop */
   SLang_free_slstring(arg1);
free_and_return_2:
   SLang_free_slstring(arg2);
usage_label:
   if (issue_usage) Slirp_usage (4, 4, 0);
}

static void sl_cure_get_eol (void)
{
   int retval;
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 0) goto usage_label;
   issue_usage = 0;

   retval = slang_api__cure_get_eol();
   (void)SLang_push_int(retval);
   goto free_and_return;
free_and_return:
   /* drop */
usage_label:
   if (issue_usage) Slirp_usage (5, 5, 0);
}

static void sl_cure_get_bol (void)
{
   int retval;
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 0) goto usage_label;
   issue_usage = 0;

   retval = slang_api__cure_get_bol();
   (void)SLang_push_int(retval);
   goto free_and_return;
free_and_return:
   /* drop */
usage_label:
   if (issue_usage) Slirp_usage (6, 6, 0);
}

static void sl_cure_delete (void)
{
   int retval;
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 0) goto usage_label;
   issue_usage = 0;

   retval = slang_api__cure_delete();
   (void)SLang_push_int(retval);
   goto free_and_return;
free_and_return:
   /* drop */
usage_label:
   if (issue_usage) Slirp_usage (7, 7, 0);
}

static void sl_cure_cursor_move (void)
{
   int arg1;
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 1) goto usage_label;
   if (-1 == SLang_pop_int((int*)&arg1)) goto usage_label;
   issue_usage = 0;

   slang_api__cure_cursor_move( arg1);
   goto free_and_return;
free_and_return:
   /* drop */
usage_label:
   if (issue_usage) Slirp_usage (8, 8, 0);
}

static void sl_cure_cursor_offset (void)
{
   int retval;
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 0) goto usage_label;
   issue_usage = 0;

   retval = slang_api__cure_cursor_offset();
   (void)SLang_push_int(retval);
   goto free_and_return;
free_and_return:
   /* drop */
usage_label:
   if (issue_usage) Slirp_usage (9, 9, 0);
}

static void sl_listbox_with_data (void)
{
   char* retval;
   int arg1;
   int arg2;
   char* arg3;
   char** arg4;
   Slirp_Ref *arg4_r = ref_new(SLANG_STRING_TYPE,sizeof(char*),&arg4,0x0);
   unsigned long arg5;
   char** arg6;
   Slirp_Ref *arg6_r = ref_new(SLANG_STRING_TYPE,sizeof(char*),&arg6,0x0);
   unsigned long arg7;
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 5) goto usage_label;
   if (-1 == pop_array_or_ref( arg6_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg4_r, 0x0, 0)) goto usage_label;
   if (-1 == SLang_pop_string((char**)&arg3)) goto usage_label;
   if (-1 == SLang_pop_int((int*)&arg2)) goto free_and_return_3;
   if (-1 == SLang_pop_int((int*)&arg1)) goto free_and_return_3;
   issue_usage = 0;

   arg5 = (unsigned long) ref_get_size(arg4_r, 1);
   arg7 = (unsigned long) ref_get_size(arg6_r, 1);
   retval = slang_api__listbox_with_data( arg1,  arg2, arg3, arg4,  arg5, arg6,  arg7);
   (void)SLang_push_malloced_string(retval);
   goto free_and_return;
free_and_return:
   /* drop */
free_and_return_3:
   SLang_free_slstring(arg3);
usage_label:
   if (issue_usage) Slirp_usage (10, 10, 0);
   finalize_refs(2,arg4_r,arg6_r); 
}

static void sl_cure_get_left_whole_word (void)
{
   char* retval;
   int arg1;
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 1) goto usage_label;
   if (-1 == SLang_pop_int((int*)&arg1)) goto usage_label;
   issue_usage = 0;

   retval = slang_api__cure_get_left_whole_word( arg1);
   (void)SLang_push_malloced_string(retval);
   goto free_and_return;
free_and_return:
   /* drop */
usage_label:
   if (issue_usage) Slirp_usage (11, 11, 0);
}

static void sl_listbox (void)
{
   int retval;
   int arg1;
   int arg2;
   char* arg3;
   char** arg4;
   Slirp_Ref *arg4_r = ref_new(SLANG_STRING_TYPE,sizeof(char*),&arg4,0x0);
   unsigned long arg5;
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 4) goto usage_label;
   if (-1 == pop_array_or_ref( arg4_r, 0x0, 0)) goto usage_label;
   if (-1 == SLang_pop_string((char**)&arg3)) goto usage_label;
   if (-1 == SLang_pop_int((int*)&arg2)) goto free_and_return_3;
   if (-1 == SLang_pop_int((int*)&arg1)) goto free_and_return_3;
   issue_usage = 0;

   arg5 = (unsigned long) ref_get_size(arg4_r, 1);
   retval = slang_api__listbox( arg1,  arg2, arg3, arg4,  arg5);
   (void)SLang_push_int(retval);
   goto free_and_return;
free_and_return:
   /* drop */
free_and_return_3:
   SLang_free_slstring(arg3);
usage_label:
   if (issue_usage) Slirp_usage (12, 12, 0);
   finalize_refs(1,arg4_r); 
}

static void sl_message (void)
{
   char* arg1;
   char* arg2;
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 2) goto usage_label;
   if (-1 == SLang_pop_string((char**)&arg2)) goto usage_label;
   if (-1 == SLang_pop_string((char**)&arg1)) goto free_and_return_2;
   issue_usage = 0;

   slang_api__message(arg1, arg2);
   goto free_and_return;
free_and_return:
   /* drop */
   SLang_free_slstring(arg1);
free_and_return_2:
   SLang_free_slstring(arg2);
usage_label:
   if (issue_usage) Slirp_usage (13, 13, 0);
}

static void sl_listbox_auto (void)
{
   int retval;
   char* arg1;
   char** arg2;
   Slirp_Ref *arg2_r = ref_new(SLANG_STRING_TYPE,sizeof(char*),&arg2,0x0);
   unsigned long arg3;
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 2) goto usage_label;
   if (-1 == pop_array_or_ref( arg2_r, 0x0, 0)) goto usage_label;
   if (-1 == SLang_pop_string((char**)&arg1)) goto usage_label;
   issue_usage = 0;

   arg3 = (unsigned long) ref_get_size(arg2_r, 1);
   retval = slang_api__listbox_auto(arg1, arg2,  arg3);
   (void)SLang_push_int(retval);
   goto free_and_return;
free_and_return:
   /* drop */
   SLang_free_slstring(arg1);
usage_label:
   if (issue_usage) Slirp_usage (14, 14, 0);
   finalize_refs(1,arg2_r); 
}

static void sl_cure_get_byte (void)
{
   int retval;
   int arg1;
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 1) goto usage_label;
   if (-1 == SLang_pop_int((int*)&arg1)) goto usage_label;
   issue_usage = 0;

   retval = slang_api__cure_get_byte( arg1);
   (void)SLang_push_int(retval);
   goto free_and_return;
free_and_return:
   /* drop */
usage_label:
   if (issue_usage) Slirp_usage (15, 15, 0);
}

static void sl_action (void)
{
   int retval;
   SLang_Array_Type* proxy1 = NULL;
   void* arg1;
   char* arg2;
   long arg3;
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 1) goto usage_label;
   if (-1 == SLang_pop_array((SLang_Array_Type**)&proxy1)) goto usage_label;
   issue_usage = 0;

    {
        /* Called with string argument? */
        if (proxy1->data_type == SLANG_STRING_TYPE) {
            arg2 = *((char**)proxy1->data);
            arg3 = -1;
        } else {
            /* It's certain that no string will be passed. */
            arg2 = NULL;
            /* Called with a long argument? */
            if (proxy1->data_type == SLANG_LONG_TYPE)
                arg3 = *((long*)proxy1->data);
            /* Called with an integer argument? */
            else if (proxy1->data_type == SLANG_INT_TYPE)
                arg3 = *((int*)proxy1->data);
            /* Unknown type passed as argument – signal/mark the error with a special value. */
            else
                arg3 = 0xbadc0de;
        }
        /*
         * The first parameter is only a placeholder of the void * arbitrary type argument
         * on S-Lang side, it's unused on C side.
         */
        arg1 = 0;
    }
   retval = slang_api__action(arg1, arg2,  arg3);
   (void)SLang_push_int(retval);
   goto free_and_return;
free_and_return:
   /* drop */
   SLang_free_array(proxy1);
usage_label:
   if (issue_usage) Slirp_usage (16, 16, 0);
}

static void sl_cure_insert_ahead (void)
{
   int arg1;
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 1) goto usage_label;
   if (-1 == SLang_pop_int((int*)&arg1)) goto usage_label;
   issue_usage = 0;

   slang_api__cure_insert_ahead( arg1);
   goto free_and_return;
free_and_return:
   /* drop */
usage_label:
   if (issue_usage) Slirp_usage (17, 17, 0);
}


static SLang_Intrin_Fun_Type slang_api_functions_Funcs [] =
{
   MAKE_INTRINSIC_0((char*)"set_action_hook",sl_set_action_hook,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"cure_backspace",sl_cure_backspace,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"add_new_action",sl_add_new_action,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"editor_map_key_to_func",sl_editor_map_key_to_func,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"editor_map_key_to_action",sl_editor_map_key_to_action,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"cure_get_eol",sl_cure_get_eol,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"cure_get_bol",sl_cure_get_bol,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"cure_delete",sl_cure_delete,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"cure_cursor_move",sl_cure_cursor_move,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"cure_cursor_offset",sl_cure_cursor_offset,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"listbox_with_data",sl_listbox_with_data,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"cure_get_left_whole_word",sl_cure_get_left_whole_word,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"listbox",sl_listbox,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"message",sl_message,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"listbox_auto",sl_listbox_auto,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"cure_get_byte",sl_cure_get_byte,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"action",sl_action,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"cure_insert_ahead",sl_cure_insert_ahead,SLANG_VOID_TYPE),
   SLANG_END_INTRIN_FUN_TABLE
};   /* }}} */

static const char* usage_strings[] = { /* {{{ */
   "int = set_action_hook(string,string,string)",
   "int = cure_backspace()",
   "int = add_new_action(string,int)",
   "int = editor_map_key_to_func(string,string,string)",
   "int = editor_map_key_to_action(string,string)",
   "int = cure_get_eol()",
   "int = cure_get_bol()",
   "int = cure_delete()",
   "cure_cursor_move(int)",
   "int = cure_cursor_offset()",
   "string = listbox_with_data(int,int,string,string[],string[])",
   "string = cure_get_left_whole_word(int)",
   "int = listbox(int,int,string,string[])",
   "message(string,string)",
   "int = listbox_auto(string,string[])",
   "int = cure_get_byte(int)",
   "int = action(array)",
   "cure_insert_ahead(int)",
NULL
}; /* }}} */

static void Slirp_usage(int i, int last, int flags) /* {{{ */
{
   char *indent;
   int npop = SLstack_depth();
   if (npop > SLang_Num_Function_Args) npop = SLang_Num_Function_Args;
   SLdo_pop_n(npop);
   if (last == i)
	indent = (char*)"Usage:  ";
   else {
	indent = (char*)"\t";
	SLang_verror(SL_USAGE_ERROR, (char*)"Usage: one of");
   }
   do
	SLang_verror(SL_USAGE_ERROR, (char*)"%s%s", indent, usage_strings[i++]);
   while (i < last);
   if (flags & 0x2)
	SLang_verror(SL_USAGE_ERROR,
		(char*)"\tThis function has been vectorized and parallelized.");
   else if (flags & 0x1)
	SLang_verror(SL_USAGE_ERROR, (char*)"\tThis function has been vectorized.");
} /* }}} */

#define SLIRP_VERSION_STRING pre2.0.0-34
#define SLIRP_VERSION_NUMBER 20000
SLANG_MODULE(slang_api_functions);
int init_slang_api_functions_module_ns(char *ns_name)	/* {{{ */
{
   SLang_NameSpace_Type *ns = NULL;

   if (slang_abi_mismatch()) return -1;
   if (ns_name != NULL) {
	ns = SLns_create_namespace (ns_name);
       if (ns == NULL ||
          (slns = SLmalloc(strlen(ns_name)+1)) == NULL)
          return -1;
       strcpy(slns, ns_name);
   }


   if (allocate_reserved_opaque_types() == -1) return -1;
#ifdef HAVE_OPAQUE_IVARS
   if (-1 == set_opaque_ivar_types(slang_api_functions_Opaque_IVars) ||
       -1 == SLns_add_intrin_var_table(ns,slang_api_functions_Opaque_IVars,NULL))
	return -1;
#endif

   if (	-1 == SLns_add_intrin_fun_table (ns,slang_api_functions_Funcs,(char*)"__slang_api_functions__"))
	return -1;

   return 0;
} /* }}} */
